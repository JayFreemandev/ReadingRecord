# Item13, clone 재정의는 주의해서 진행하라

### Cloneable 인터페이스를 열어보면 메서드가 없는 깡통이다.

clone메서드는 원본 객체의 필드 값을 복사해서 새로운 객체를 생성해준다.

사용하기 위해서는 해당 클래스에서 Cloneable 인터페이스의 구현이 선행되어야한다.

하지만, clone메서드는 Object에 선언되어있고 protected라 Override 해주어야 사용가능하다.

조금 이상하다. 그렇다면 Cloneable 인터페이스를 구현하고 clone 메서드를 Override하면 끝인가?

아니다. 구현한 클래스가 변하지않는 불변 객체를 참조하는 경우는 오케이. 불변이 아니라면 한쪽에

서 값이 변경될경우 같은곳을 참조하는 복사된 객체또한 문제가 생긴다. (얕은 복사)

### 올바르게 사용할려면 자신과 같은 클래스의 인스턴스를 인수로 받거나 정적 팩터리로 생성한다.

복사 생성자와 복사 팩터리는 `Cloneable/clone` 방식처럼 불필요한 `Exception` 처리를 하지 않아도 

되고 형변환도 필요하지 않으며 객체 생성 메커니즘(생성자를 쓰지 않는 방식)을 사용하지도 않는다. 

또한 해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있어 이들을 이용하면 복

제본 타입을 선택하는데 있어 유연성이 향상될 수 있다.

복사 생성자와 복사 팩토리는 Cloneable 방식보다 장점이 많다

- 생성자를 쓰지 않는 방식의 객체 생성 메커니즘을 사용하지 않습니다.
- 엉성하게 문서화된 규약에 기대지 않정상적인 final 필드 용법과도 충돌하지 않습니다.
- 불필요한 검사 예외를 던지지 않고, 형변환도 필요치 않습니다.
- **해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있습니다.**

### 왜 배열은 clone이 적합한가

많은 예제들이 Stack을 예시로 들고있다. Clone은 사실상 생성자와 같은 역할을 하기에 배열의 경우

재귀적으로 계속 clone()을 호출해주면 얕은 복사의 문제점이 해결되서 복제된 객체의 불변을 보장한

다. 따라서 배열을 복제할 떄는 배열의 clone 메서드를 사용하면 된다. (깊은 복사) 

다른 얕은 복사 방법으로는 System.arraycopy()는 자바 네이티브 인터페이스를 사용하기에 속도가 매

우 빠른 복사 방법도 존재한다. 

### 결론

객체의 복제 기능은 `Cloneable/clone` 방식보다 복사 팩터리와 복사 생성자를 이용하는것이 가장 좋

다. 단, 배열같은 경우는 `clone()` 방식을 가장 적합하므로 예외로 친다.
