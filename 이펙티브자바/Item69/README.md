# Item69, 예외는 예외 상황에만

```jsx
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {

}
```

코드를 보면 while이 돌아가면서 배열의 마지막 인덱스를 넘으면 종료시키는 의도인데 잘못된 코드이다.

```
for (Mountain m : range)
    m.climb();
```

코드가 try catch안에 들어가면 **최적화 범위가 제한**되기때문에 위와 같이 작성하여야 한다.

왜냐하면 JVM은 배열에 접근할 때마다 인덱스 범위를 넘지않는지 매번 검사해야된다.

성능만 저하시키는게 아니라 예외안에 반복문이 들어있으면 코드가 헷갈리고 디버깅이 굉장히 힘들어진다.

- Ex. 반복문의 몸체에서 호출한 메서드 내부에서 반복문과 관련 없는 배열을 사용하다가 ArrayInexOutOfBoundsException을 일으킬 시,
    - 표준 관용구였다면 이 버그는 예외를 잡지 않고 스택 추적 정보를 남긴 후 해당 스레드를 즉각 종료했을 것이다.
    - 그러나 예외를 통해 제어 흐름을 사용했다면, 버그 때문에 발생한 엉뚱한 예외를 **정상적인 반복문에 의한 종료 상황**으로 오해하고 넘어갈 것이다.

**잘 설게된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없어야 한다.**

- 외부 동기화 없이 **여러 스레드가 동시 접근하는 경우 옵셔널이나 특정 값을 사용**한다. 상태 검사 메서드와 상태 의존적 메서드의 호출 사이에서 객체의 상태가 변할 수 있기 때문이다.
- 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존전 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
- 그 외의 경우에는 상태 검사 메서드 방식이 조금 더 낫다. 가독성이 조금 더 좋고, 잘못 사용했을 때 발견하기 쉽다. 상태 검사 메서드 호출을 잊었다면, 상태 의존적 메서드가 예외를 던져 버그 찾기가 수월할 것이다.
