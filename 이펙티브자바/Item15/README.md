# Item15, 클래스와 멤버의 접근 권한을 최소화 해라

Date: April 4, 2022

![Untitled](%E1%84%8B%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A6%E1%86%B715,%2094add/Untitled.png)

추상화의 기본 단위인 클래스와 인터페이스는 자바의 심장이다. 

4장 부터는 클래스와 인터페이스를 어떻게 편하고 견고하며 유연하게 만들지 설명한다.

### 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트와 그렇지않은 컴포넌트의 차이

는 클래스 내부 구현 정보를 외부로부터 얼마나 잘 숨겼는가, 오직 API를 통해서만 소통되는가이다.

### 캡슐화의 장점은

- 시스템 개발 속도 증가 : 여러 컴포넌트를 병렬로 개발할수있기때문이다.
- 시스템 관리 비용 감소 : 각 컴포넌트를 빨리 파악하여 디버깅 가능, 다른 컴포넌트 교체 용이
- 재사용성 증가 : 외부에 의존하지 않고 독자적으로 동작한다면 낮선 환경에서도 유용
- 큰 시스템 제작 난이도 감소 : 아직 전체가 미완성이라도 개별 컴포넌트 동작을 검증 가능

### 캡슐화의 핵심은

접근 제한자, 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.

- private : 멤버를 선언한 탑클래스에서만 접근 가능
- package-private : 멤버가 소속된 패키지안의 모든 클래스에서 접근 가능
- protectd : package-private의 범위를 포함하며 이 멤버를 선언한 하위클래스에서도 접근 가능
- public : 모든 접근 가능

모든 멤버 변수는 private으로 선언하고 오직 같은 패키지의 다른 클래스가 접근해야하는 멤버만 

(private 해제) package-private를 걸어주자. private과 package-private은 해당 클래스 구현이라 다른 

API들에게 영향을 주지 않는다. protected로 넘어가는순간 공개되는 범위가 매우 넓어지게된다. 

*protected 선언은 적을수록 좋다.*

### 유일한 제약

멤버 접근성을 좁히지 못하게 하는 제약이 하나 있다. 

상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스보다 좁게 잡을 수 없다.

**리스코프 치환원칙**에 의해 상위 클래스는 하위 클래스로 언제나 대체 가능해야하기 때문이다.

### 결론

따라서 public 클래스의 인스턴스 필드는 되도록 public이 아니여야한다.

필드가 가변 객체를 참조하거나 final이 아닌 인스턴스 필드를 pulbic 선언시 더이상 불변을 보장하지

못하게 된다. + 필드가 수정될 때 다른 작업을 할 수 없게 되므로 스레드에서 안전하지도 않다. 

심지어 필드가 final이면서 불변을 참조하더라도 문제가 남는다. 내부 구현을 바꾸고 싶어도

그 public 필드를 없애는 방식으로는 리팩터링 할 수 없게 된다.  정적 필드도 똑같다. 

public static final 상수같은경우는 기본 타입이나 불변을 참조한다면 오케이 하지만 **길이가 0이 아닌** 

**배열일 경우  static final 배열 필드를 두거나 이 필드를 반환하는 접근자 제공하면 큰일난다.** 

수정되기때문이다.

길이가 0이 아닌 배열을 꼭 static final로 지정해야한다면 public을 private로 바꾸고 배열을 

변경이 불가능한 pulbic static final List로 만드는 방법이 있다. 

아니면 이전 Item에서 나온 clone으로 바꿔도 영향안가게 배열.clone() 하는 pulbic 메서드 만들어라.
