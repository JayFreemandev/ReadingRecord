# Item2, 생성자에 매개변수가 많다면 빌더

# **점증적 생성자 패턴**

정적 팩토리와 생성자는 선택적 매개변수가 많을 때 적절한 대응을 하기가 어렵다. 생성자의 매개변수가 많을 때는 우선 **점층적 생성자 패턴**을 고려해볼 수 있다.

아래 예시는 매개변수를 전달하지 않으면 기본값으로 0을 전달한다고 가정한다.

```java
public class Foo {
    private int a;
    private int b;
    private int c;

    public Foo(int a) {
        this(a, 0, 0)
    }

    public Foo(int a, int b) {
        this(a, b, 0)
    }

    public Foo(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}
```

점층적 생성자 패턴의 **단점**은 **1.결국엔 클라이언트가 사용하길 원하지 않는 매개변수까지 포함해야되는 일이 생긴다는 것**이다. 위 예시를 예로 들면 만약 매개변수 c에만 값을 전달하고 싶으면 결국 `new Foo(0, 0, 10)` 이렇게 코드를 작성해야된다는 것이다.

또 **2.같은 타입의 매개변수가 여러 개 있는 경우, 클라이언트에서 순서를 잘못 전달해도 컴파일 타임에 오류를 잡을 수 없다.** 예를 들어 a=1, b=2, c=3 이렇게 값을 전달하려했는데 실수로 `new Foo(2, 1, 3)` 이렇게 전달해도 오류없이 컴파일된다.

# 자바빈즈 패턴

다른 대안으로 **자바빈즈 패턴**을 고려해볼 수 있는데, 기본 생성자를 하나 두고, setter 메서드로 값을 설정하는 것이다. 근데 이 방식은 치명적인 단점이 두 가지 있다.

- 여러 필드의 값을 설정하려면 세터 메서드를 여러번 호출해야되는데, 
이 사이에 객체의 일관성이 깨진다.

```java
TestVO testVO = new TestVO();

testVO.setUSerIdx(1);
testVO.setUserName("kimseohae");
testVO.setTitle("test");
testVO.setTitleA("test");
testVO.setTitleB("test");
testVO.setTitleC("test");
..
testVO.setTitleD("test");
```

TestVo의 필드값이 20개라면 20개를 set을 해줘야하는데 그만큼의 set을 호출해야한다. 

큰 단점은 객체를 생성한 이후에 Setter 메서드를 호출하므로, **필요한 Setter가 모두 호출되기 전까지는 객체는 완전한 상태가 아니다**. 객체를 생성하고 필요한 Setter 메서드를 호출하더라도 코드 어디에선가 누군가 잘못된 Setter를 호출하면 객체는 변하게 된다.

즉 객체의 잘못된 값 설정으로 인해 런타임에서 프로그램이 오류를 범할 수 있는 위험이 항상 존재한다.

- 불변으로 만들 수 없다(필드에 final 키워드를 선언할 수 없기때문).

일관성이 깨지면 클래스는 불변으로 만들수가없다. 가독성은 좋지만 안정성이 너무 떨어지는 방법이다. 스레드 안정성을 얻기 위해 개발자가 동기화 작업을 추가적으로 진행해야한다. 이때 성능저하의 이슈를 피할수없다.