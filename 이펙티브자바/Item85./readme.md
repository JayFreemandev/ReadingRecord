# Item 85, 자바 직렬화의 대안을 찾으라자바 직렬화의 대안을 찾으라

# 정리

- 직렬화는 어떤 데이터를 다른 데이터의 형태로 변환하는 것이다. 신뢰할 수 없는 역직렬화하는 것 자체가 스스로를 공격에 노출하는 행위다역직렬화를 해야한다면 ObjectInputFilter를 사용하자
- 외부 저장소로 저장되는 데이터는 짧은 만료시간의 데이터를 제외하고 자바 직렬화를 사용을 지양합니다.
- 역직렬화시 반드시 예외가 생긴다는 것을 생각하고 개발합니다.
- 자주 변경되는 비즈니스적인 데이터를 자바 직렬화을 사용하지 않습니다.
- 긴 만료 시간을 가지는 데이터는 JSON 등 다른 포맷을 사용하여 저장합니다.

# 

## **직렬화란?**

넓은 의미로 직렬화는 어떤 데이터를 다른 데이터의 형태로 변환하는 것
이팩티브 자바에서 말하는 직렬화(Serializable)란 바이트 스트림으로의 직렬화로 객체의 상태를 바이트 스트림으로 변환하는 것을 의미
반대로 바이트 스트림에서 객체의 상태로 변환하는 건 역직렬화(Deserializable)

### **그럼 바이트 스트림이란?**

스트림은 데이터의 흐름. 데이터의 통로라고도 이야기
예를 들어, 웹 개발을 하다보면 클라이언트에서 서버에게 데이터를 보내는 일이 있다.
이처럼 스트림은 클라이언트와 서버같이 어떤 출발지와 목적지로 입출력하기 위한 통로
자바는 이런 입출력 스트림의 기본 단위를 바이트로 두고 있고 입력으로는 InputStream, 출력으로는 OutputStream라는 추상클래스로 구현되어 있다.

## **왜 직렬화를 사용할까?**

일단 자바에서 표현된 객체를 목적지에 보냈다고 했을 때 그 곳에서 아 이게 자바 객체구나~하고 바로 알 수가 없다.    
목적지에서 객체를 알 수 있는 방법이 없기에 모두가 다 알 수 있는 것으로 변환을 해줘야 한다.   
여기서 변환을 도와주는 방법이 직렬화이며 직렬화를 통해서 바이트 스트림으로 변환해줄 수 있다.   

JVM메모리에만 상주해있는 데이터들을 영속화(PERSISTENCE)할때 필요하다.   
시스템이 종료되더라도 없어지지 않는 영속성 데이터라 네트워크 전송도 가능하다.   
대표적인 예로 서블릿 세션(톰캣)들이 직렬화를 지원한다.   

파일로 저장하거나 세션 클러스터링, DB를 사용하는 옵션 또한 세션 자체가 직렬화되어 전달한다.

자바에서는 퍼포먼스를 위해 캐시(Ehcache, redis, memcached)와 같은 라이브러리들을 많이 사용하는데 많은 클래스가 만들어지게 된다.   
예를 들면 DB를 조회한 후 가져온 데이터 객체 같은 경우 실시간 형태로 요구하는 데이터가 아니라면메모리,   
외부 저장소, 파일 등을 저장소를 이용해서 데이터 객체를 저장한 후 동일한 요청이 오면 DB를 다시 요청하는 것이 아니라   
저장된 객체를 찾아서 응답하게 하는 형태를 보통 캐시를 사용한다  

캐시를 이용하면 DB에 대한 리소스를 절약할 수 있기 때문에 많은 시스템에서 자주 활용.
(사실 이렇게 간단하진 않다)이렇게 캐시 할 부분을 자바 직렬화된 데이터를 저장해서 사용됩니다.   
물론 자바 직렬 화만 이용해서만 캐시를 저장하지 않지만 가장 간편하기 때문에 많이 사용된다.   

### serialVersionUID가 필수값은 아니다 
가 must 인줄 알았는데 직접 기술하지 않아도 내부적으로 정보가 추가된다는 사실을 알았다.   
하지만 집적 관리 해주는게 클래스 변경 시 혼란을 줄인다. 같은 UID일지라도 타입이 바뀌는 순간 직렬화에 실패한다.  
같은 UID를 사용할때 멤버 변수 및 메서드 추가하더라도 큰 문제가 없다. 하지만 변수 제거나 이름 변경시 데이터 누락이 된다.    

외부db에 장기간 저장될 정보는 직렬화 사용을 지양해라.   
역직렬화 대상의 클래스가 언제 변경이 일어날지 모르는 환경에서 긴 시간 동안 외부에 존재했던   
직렬화된 데이터는 쓰레기(Garbage)가 될 가능성이 높습니다.  
**언제 예외가 발생할지 모르는 지뢰 시스템이 될 수도 있습니다.**  

### **용량 문제**

자바 직렬화시에 기본적으로 타입에 대한 정보 등 클래스의 메타 정보도 가지고 있기 때문에 상대적으로 다른 포맷에 비해서 용량이 큰 문제가 있습니다. 
특히 클래스의 구조가 거대해지게 되면 용량 차이가 커지게 됩니다. 

예를 들면 클래스 안에 클래스 또 리스트 등 이런 형태의 객체를 직렬화 하게 되면 내부에 참조하고 있는 모든 클래스에 대한 메타정보를 가지고 있기 때문에 용량이 비대해지게 됩니다.그래서 JSON 같은 최소의 메타정보만 가지고 있으면 테스트로 된 포맷보다 같은 데이터에서 **최소 2배 최대 10배** 이상의 크기를 가질 수 있습니다.

용량 문제는 생각보다 많은 곳에서 나타나는 문제. 특히 직렬화된 데이터를 메모리 서버([Redis](https://redis.io/), Memcached)에 저장하는 형태를 가진 시스템에서 두드러집니다. 메모리 서버 특성상 메모리 용량이 크지 않기 때문에 핵심만 요약해서 기록하는 형태가 효율적입니다.

적은 데이터만 입력하는 시스템 구조라면 큰 문제는 발생하지 않습니다. 

하지만 트래픽에 따라 데이터 기록이 급증하는 시스템은 유의해야 합니다.

그리고 이 부분을 강조하는 이유는 자바 웹 시스템에서 가장 많이 사용되는 스프링 프레임워크에서 기본적으로 지원하는 캐시 모듈 중외부 시스템에 저장하는 형태에서 기본적으로 자바 직렬화 형태로 제공되기 때문입니다.

 (Spring Data Redis, Spring Session …)기본적으로 프레임워크에서 자바 직렬화로 제공하는 이유는 앞서 말한 자바 직렬화 장점과 일맥상통합니다. 개발자가 신경 안 쓰고 빠르게 개발할 수 있기 때문입니다 **.자바 직렬화 사용하는 시스템은 규모가 커지는 시점에서 반드시 다시 점검**하여 보시길 바랍니다.

### **용량 문제 결론**

일반 사용자를 대상으로 하는 B2C와 같은 시스템에서 자바 직렬화 정보를 외부 캐시 서버에 저장할 때에는비효율적인 문제를 가지고 있습니다. (용량 크기에 따른 네트워크 비용과 캐시 서버 비용)새롭게 스타트하는 서비스 같은 경우에는 생산성을 위해서 자바 직렬화를 그대로 이용한다고 해도 **트랙픽이 지속적으로 증가할 때에는 JSON 형태 또는 다른 형태의 직렬화로 바꿔주는 것 고려**해보시길 바랍니다.

### **호환성 이야기**

이 부분은 기술적 오류 문제는 아닙니다. 단지 자바 직렬화를 이용해서 개발하면서 불편했던 부분을 이야기하려고 합니다. 자바 직렬화를 이용해서 외부 데이터를 저장하게 되면 제일 큰 아쉬움이 바로 자바에서만 사용할 수 있으면 읽을 수 있는 문제였습니다.

다른 언어를 이용해서 스크립트를 이용해서 여러 가지 처리를 하고 싶어도 불가능에 가깝습니다.(파이썬에 자바 직렬화 분석하는 라이브러리가 있는 것은 확인해봤지만 사용은 못해봤습니다.)만약 JSON으로 저장되어 있다면 MYSQL이나 REDIS 등 추가 라이브러리를 통해 조회도 가능하면 다른 언어를 통해서도 탐색 및 조작이 가능합니다

그리고 제가 이야기하고 싶은 것은 "**긴 시간 동안 외부에 저장하는 의미 있는 데이터들은 자바 직렬화를 사용하지 말자.**"입니다.

### **왜 굳이 바이트 스트림으로 변환할까요?**

바이트인 이유는 컴퓨터에서 기본으로 처리되는 최소 단위가 바이트이기 때문이다. 완전 최소 단위로 가면 비트로도 처리할 수 있겠지만 표현할 수 있는 방법이 0과 1로 너무 적어 하나의 단위로 묶었다고 한다.

이렇게 바이트 스트림으로 변환해야 네트워크, DB로 전송할 수 있고 목적지에서도 처리를 해줄 수 있다. 쉽게 생각하면 '출발지와 목적지 모두 알아들을 수 있는 byte라는 언어로 소통할 수 있도록' 이라고 말할 수 있겠다.

### **바이트 직렬화 예시**

간단한 예시로 문자열을 서버로 보내는 TCP 클라이언트를 개발한다고하자.

이때 문자열 → 바이트 직렬화가 사용된다.

서버에 메시지를 보내기 위해 소켓에서 OutputStream(출력 스트림)을 가져와 출력하고 싶은 문자열(message)을 바이트로 바꿔 쓰게(write)된다.

```java
Socket socket = new Socket();
socket.connect(new InetSocketAddress("localhost", 5001));

byte[] bytes;
String message;

OutputStream os = socket.getOutputStream(); // 출력 스트림
message = "이펙티브 자바";
bytes = message.getBytes(StandardCharsets.UTF_8); // 문자열 -> 바이트
os.write(bytes); // 출력 스트림에 바이트를 쓰고
os.flush(); // flush를 날리면 그 소켓으로 출력이 된다
```

### **문자열 직렬화 예시**

웹 개발에서 자주 사용하는 데이터 형태인 JSON도 문자열 직렬화가 사용된다.

JSON 형태로 문자열 직렬화를 해줘야 한다. Spring Boot에서는 Jackson2가 모두 해주고 있다.

```java
@DisplayName("JSON 직렬화 테스트")
@Test
void jsonSerializable() {
    Person person = new Person("bingbong", 21);
    String json = String.format("{\"name\":\"%s\",\"age\":%d}", person.name, person.age);

    assertThat(json).isEqualTo("{\"name\":\"bingbong\",\"age\":21}");
}
```

## **어떻게 객체에서 바이트 직렬화를 할까?**

객체에 Serializable 이라는 인터페이스를 구현하면 된다.

참고로 Serializable 은 안에 아무것도 선언되어있지 않습니다. 이를 마커 인터페이스라고 부른다.

말 그대로 직렬화를 할 수 있는 객체라고 알려주는 것이다.

그리고 나서 목적지까지 가는 바이트 스트림에 writeObject를 사용해준다.

```java
@DisplayName("Serializable을 구현한 Person 객체 직렬화 테스트")
@Test
void writeObjectTest() throws IOException {
    Person person = new Person("bingbong", 21);

    byte[] serializedPerson;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(person);
            // 직렬화된 Person 객체
            serializedPerson = baos.toByteArray();
        }
    }
    // 요런 식으로 나옴
    // -84, -19, 0, 5, 115, 114, 0, 57, 99, 111, 109, 46, 98, 105, 110, 103, 98, 111, 110, 103, 46, 101, 102, 102, 101, 99, 116, 105, 118, 101, 106, 97, 118, 97, 46, 105, 116, 101, 109, 56, 53, 46, 83, 101, 114, 105, 97, 108, 105, 122, 97, 98, 108, 101, 84, 101, 115, 116, 36, 80, 101, 114, 115, 111, 110, -126, 113, -121, -86, 125, 92, 57, 9, 2, 0, 2, 73, 0, 3, 97, 103, 101, 76, 0, 4, 110, 97, 109, 101, 116, 0, 18, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 120, 112, 0, 0, 0, 21, 116, 0, 8, 98, 105, 110, 103, 98, 111, 110, 103
    assertThat(serializedPerson).isNotEmpty();
}

static class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

### **그렇다면 역직렬화는?**

```java
@DisplayName("Serializable을 구현한 Person 객체 직렬화 후, 역직렬화 테스트")
@Test
void writeObjectTest2() throws IOException {
    Person person = new Person("bingbong", 21);

    byte[] serializedPerson;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(person);
            // 직렬화된 Person 객체
            serializedPerson = baos.toByteArray();
        }
    }

    Person deSerializedPerson = null;

    try (ByteArrayInputStream bais = new ByteArrayInputStream(serializedPerson)) {
        try (ObjectInputStream ois = new ObjectInputStream(bais)) {
            // 역직렬화된 Person 객체
            deSerializedPerson = (Person) ois.readObject();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    assertThat(deSerializedPerson).isNotNull();
    assertThat(deSerializedPerson.name).isEqualTo("bingbong");
    assertThat(deSerializedPerson.age).isEqualTo(21);
}
```

이 외에도 CSV나 JSON과 같은 직렬화 방법이 존재한다. 

어떤 직렬화 방법을 쓰던 정답은 없고 목적에 따라 달라진다. 

자바 직렬화는 자바 시스템 개발에 최적화 되어있다. 직렬화 조건만 지켜진다면 큰 작업 없이 바로 

기존 객체처럼 사용할 수 있다. 역직렬화도 마찬가지다. 

### **객체와 바이트 시퀀스를 변환해주는 다른 메커니즘, 크로스 플랫폼**

객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있다. 이 방식들은 자바 직렬화의 여러 위험을 회피하면서 다양한 플랫폼 지원, 우수한 성능, 풍부한 지원 도구, 활발한 커뮤니티와 전문가 집단 등 수많은 이점까지 제공한다. 

이런 메커니즘들도 직렬화 시스템이라 불리기도 하지만, 이 책에서는 자바 직렬화와 구분하고자 **크로스-플랫폼 구조화된 데이터 표현**이라 한다.

이 표현들의 공통점은 자바 직렬화보다 훨씬 간단하는 것이다. 임의 객체 그래프를 자동으로 직렬화역직렬화하지 않는다. 대신 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용한다. 

그리고 기본 타입 몇 개와 배열 타입만 지원할 뿐이다. 이런 간단한 추상화만으로도 아주 강력한 분산 시스템을 구축하기에 충분하고, 자바 직렬화가 가져온 심각한 문제들을 회피할 수 있음이 밝혀졌다.

### **크로스 플랫폼의 대표주자 JSON과 프로토콜 버퍼**

크로스-플랫폼 구조화된 데이터 표현의 선두주자는 JSON과 프로토콜 버퍼다.

### **JSON**

- JSON은 더글라스 크록퍼드가 브라우저와 서버의 통신용으로 설계
- 언어 중립적이지만 자바 스크립트용으로 만들어진 흔적이 있음

### **프로토콜 버퍼**

- 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계
- 프로토콜 버퍼는 C++용으로 만들어졌고 아직 그 흔적이 남아있음.

### **JSON과 프로토콜 버퍼의 차이점**

- JSON은 텍스트 기반이라 사람이 읽을 수 있고, 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 높다는 점이다.
- JSON은 오직 데이터를 표현하는 데만 쓰이지만, 프로토콜 버퍼는 문서를 위한 스키마(타입)을 제공하고 올바르게 쓰도록 강요한다.
- 효율은 프로토콜 버퍼가 훨씬 좋지만 텍스트기반 표현에는 JSON이 아주 효과적이다.
- 프로토콜 버퍼는 이진 표현 뿐만 아니라 사람이 읽을 수 있는 텍스트 표현(pbtxt)도 지원한다.

## **이런 직렬화가 왜 문제가 될까?**

직렬화의 근본적인 문제는 **공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점**

직렬화를 하고 나서 역직렬화를 할 때 문제

1. 객체를 읽는 readObject 메서드는 클래스 패스에 존재하는 모든 타입의 객체를 만들어낼 수 있다.
    1. 반환 타입이 Object이다.
2. 바이트 스트림을 역직렬화하는 과정에서 해당 타입 안의 모든 코드를 수행할 수 있다.
    1. 객체를 아예 불러올 수 있으므로 모든 코드를 수행할 수 있다.
3. 그렇기에 타입 전체가 전부 공격 범위에 들어가게 된다.
4. 용량도 다른 포맷에 비해서 몇 배 이상의 크기를 가진다.
5. 또한 역직렬화 폭탄을 맞을 수도 있습니다.

바이트 스트림으로 직렬화하는데는 시간이 별로 걸리지 않지만 역직렬화를 잘못하면 안으로 들어가

서 hashCode 메서드를 계속 호출해야하기때문에 시간이 엄청 오래걸립니다. 아래 예시가 있습니다.

역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드를 가젯이라고 부르는데 

아래와 같은 해쉬폭탄 가젯이 존재한다.

```java
@DisplayName("역직렬화 폭탄 테스트")
@Test
void deserializeBomb() {
    byte[] bomb = bomb();

    // 역직렬화를 하면 엄청 많은 시간이 걸린다.
    deserialize(bomb);
    assertThat(bomb).isNotEmpty();
}

static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo");
        s1.add(t1);
        s1.add(t2);
        s2.add(t1);
        s2.add(t2);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root); // 직렬화 수행
}
```

![https://raw.githubusercontent.com/aegis1920/aegis1920.github.io/master/wiki-img/effective_java/serializebomb.png](https://raw.githubusercontent.com/aegis1920/aegis1920.github.io/master/wiki-img/effective_java/serializebomb.png)

## **그럼 어떻게 해야하나?**

가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다. 직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 java 9에 나온 ObjectInputFilter를 사용하는 것도 방법이다. 이는 데이터 스트림이 역직렬화되기 전에 필터를 적용해서 특정 클래스를 받아들이거나 거부할 수 있다.

## 정리

> 직렬화는 어떤 데이터를 다른 데이터의 형태로 변환하는 것이다. 신뢰할 수 없는 역직렬화하는 것 자체가 스스로를 공격에 노출하는 행위다역직렬화를 해야한다면 ObjectInputFilter를 사용하자
> 

Reference

우아한 형제들 기술 블로그

effective java 김지애님, 이호빈님
