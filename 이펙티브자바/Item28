# Item28, 배열보다는 리스트를 사용하라. (1)

Date: April 20, 2022

## 배열과 리스트의 차이

1. 상위타입의 배열은 하위타입도 받을 수 있어, 데이터 삽입에 대한 에
러를 런타임시 확인 가능하다. 하지만, 리스트는 컴파일 에러가 발생해서 쉽게 찾을수 있다.
- 공변: 상위타입으로 하위 타입을 받을 수 있다.
- 불공변: 상위타입으로 하위 타입을 받을 수 없다.

```jsx

   public void 배열_에러_런타임() {
        Object[] objects = new Long[1];
        objects[0] = "런타임시 에러";
    }

 
   public void 리스트는_컴파일에서_에러() {
        List<Object> list = new ArrayList<Long>(); //컴파일 에러

        list.add("컴파일 에러");
    }
```

## **SuppressWarnings**

경고를 제거할 수 없지만 타입 안전하다고 확실할 수 있으면 @SuppressWarnings("unchecked") 애너

테이션을 달아 경고를 숨기자. *안전하다고 검증된 비검사 경고를 그대로 두면, 진짜 문제를 알리는* 

*새로운 경고가 나와도 눈치채지 못할 수 있다.*

@SuppressWarnings는 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있다

하지만, **@SuppressWarnings 애너테이션은 항상 가능한 한 좁은 범위에 적용하자** 자칫 심각한 경고

를 놓칠 수 있으니 절대로 클래스 전체에 적용해서는 안 된다. 

또한, 한 줄이 넘는 메서드나 생성자에 달린 @SuppressWarnings을 발견하면 지역변수 선언 쪽으로 

옮기자 ArrayList 컴파일 시 경고가 발생하는데, 애너테이션은 선언에만 달 수 있어서 return 문에는 

@SuppressWarnings를 다는 게 불가능하다

## 배열과 리스트는 물과 기름

배열은 실체화(reify)된다. 즉, 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한

다. Long 배열에 String을 넣으려고하면 ArrayStoreException이 발생한다.

반면에 제네릭은 타입 정보가 런타임에 소거된다. 

따라서 런타임시에는 어떠한 타입도 들어올 수 있다. 

하지만 컴파일 타임에서 이를 걸러내기 때문에 안전한다. 

원소 타입을 컴파일타임에만 검사하며 런타임에는 알수조차 없다는 뜻이다.

이러한 차이점으로 배열과 제네릭은 잘 어우러지지 못한다. 

배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.

## **제네릭 배열을 만들지 못하게 막은 이유**

타입이 안전하지 않기 때문이다. 만약 허용한다면 컴파일러가 자동 생성한 형 변환 코드에서 런타임

에 ClassCastException이 발생할 수 있다. 하지만 이건 제네릭 타입 시스템의 취지에 어긋난다.

## **실체화 불가 타입**

E, List<E>, List<String> 같은 타입을 **실체화 불가 타입**이라 한다. 쉽게 말해, 실체화되지 않아서 **런타**

**임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입**이다. 매개변수화 타입 가운데 실체화될 수 있

는 타입은 List<?>와 Map<?,?> 같은 비한정적 와일드카드 타입뿐이다

```jsx
//배열을 사용할 경우
public void chooser(Collection<T> choices) {
    T[] array = (T[]) choices.toArray();
    ...
}

//배열을 리스트로 변경
public void chooser(Collection<T> choices) {
    List<T> list = new ArrayList<>(choices);
    ...
}
```

## 결론

배열은 제네릭과 어울리지않는다 왜? 런타임에서 자유롭지 못하니까 

리스트는 제네릭과 어울리는 타입이다. 런타임에서 타입 정보가 사라져 자유로우니까.
